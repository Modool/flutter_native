import 'package:flutter_native_runtime/flutter_native_runtime.dart';

import 'application_info.dart';
import 'asset_manager.dart';
import 'resources.dart';
import 'shared_preference.dart';

class Context {
  Context(this._target);

  factory Context.global() => Context(globalTarget);

  static final globalTarget =
      NativeRuntime().instanceNamed('Registrar').property('context');

  final NativeTarget _target;

  /// Returns an AssetManager target for the application's package.
  ///
  /// @return an AssetManager instance for the application's package
  /// @see #getResources()
  ///
  AssetManager get assets => AssetManager.from(_target.method('getAssets'));

  /// Returns a Resources target for the application's package.
  ///
  /// @return a Resources instance for the application's package
  /// @see #getAssets()
  ///
  Resources get resources => Resources.from(_target.method('getResources'));

  /// Return PackageManager target to find global package information. */
  NativeTarget get packageManager => _target.method('getPackageManager');

  /// Return a ContentResolver target for your application's package. */
  NativeTarget get contentResolver => _target.method('getContentResolver');

  /// Return the Looper target for the main thread of the current process.  This is
  /// the thread used to dispatch calls to application components (activities,
  /// services, etc).
  ///
  /// @return The main looper.
  ///
  NativeTarget get mainLooper => _target.method('getMainLooper');

  /// Return an {@link Executor} that will run enqueued tasks on the main
  /// thread associated with this context. This is the thread used to dispatch
  /// calls to application components (activities, services, etc).
  ///
  NativeTarget get mainExecutor => _target.method('getMainExecutor');

  /// Return the context of the single, global Application object of the
  /// current process.  This generally should only be used if you need a
  /// Context whose lifecycle is separate from the current context, that is
  /// tied to the lifetime of the process rather than the current component.
  ///
  NativeTarget get applicationContext =>
      _target.method('getApplicationContext');

  /// Return a localized, styled CharSequence from the application's package's
  /// default string table.
  ///
  /// @param resId Resource id for the CharSequence text
  ///
  Future<String> text(int resourceId) async =>
      _target.method('getText', arguments: [resourceId]).invoke<String>();

  /// Returns a localized string from the application's package's
  /// default string table.
  ///
  /// @param resId Resource id for the string
  /// @return The string data associated with the resource, stripped of styled
  ///         text information.
  ///
  Future<String> string(int resourceId) =>
      _target.method('getString', arguments: [resourceId]).invoke<String>();

  /// Returns a localized formatted string from the application's package's
  /// default string table, substituting the format arguments as defined in
  /// {@link java.util.Formatter} and {@link java.lang.String#format}.
  ///
  /// @param resId Resource id for the format string
  /// @param formatArgs The format arguments that will be used for
  ///                   substitution.
  /// @return The string data associated with the resource, formatted and
  ///         stripped of styled text information.
  ///
  Future<String> stringWithFromat(int resourceId, List<String> formatArgs) {
    final arguments = <dynamic>[resourceId];
    arguments.addAll(formatArgs);

    return _target.method('getString', arguments: arguments).invoke<String>();
  }

  /// Returns a color associated with a particular resource ID and styled for
  /// the current theme.
  ///
  /// @param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  /// @return A single color value in the form 0xAARRGGBB.
  /// @throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  ///
  Future<int> color(int resourceId) =>
      _target.method('getColor', arguments: [resourceId]).invoke<int>();

  /// Returns a drawable target associated with a particular resource ID and
  /// styled for the current theme.
  ///
  /// @param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  /// @return An object that can be used to draw this resource.
  /// @throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  ///
  NativeTarget drawable(int resourceId) =>
      _target.method('getDrawable', arguments: [resourceId]);

  /// Returns a ColorStateList target associated with a particular resource ID and
  /// styled for the current theme.
  ///
  /// @param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  /// @return A color state list.
  /// @throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  ///
  NativeTarget colorStateList(int resourceId) =>
      _target.method('getColorStateList', arguments: [resourceId]);

  /// Set the base theme for this context.  Note that this should be called
  /// before any views are instantiated in the Context (for example before
  /// calling {@link android.app.Activity#setContentView} or
  /// {@link android.view.LayoutInflater#inflate}).
  ///
  /// @param resid The style resource describing the theme.
  ///
  Future<void> setTheme(int resourceId) =>
      _target.method('setTheme', arguments: [resourceId]).invoke<void>();

  /// @hide Needed for some internal implementation...  not public because
  /// you can't assume this actually means anything. */
  Future<int> themeResId() => _target.method('getThemeResId').invoke<int>();

  /// Return the Theme target associated with this Context.
  ///
  NativeTarget get theme => _target.method('getTheme');

  /// Return a class loader you can use to retrieve classes in this package.
  ///
  NativeTarget get classLoader => _target.method('getClassLoader');

  /// Return the name of this application's package. */
  Future<String> get packageName =>
      _target.method('getPackageName').invoke<String>();

  /// @hide Return the name of the base context this context is derived from. */
  Future<String> get basePackageName =>
      _target.method('getBasePackageName').invoke<String>();

  /// @hide Return the package name that should be used for app ops calls from
  /// this context.  This is the same as {@link #getBasePackageName()} except in
  /// cases where system components are loaded into other app processes, in which
  /// case this will be the name of the primary package in that process (so that app
  /// ops uid verification will work with the name). */
  Future<String> get opPackageName =>
      _target.method('getOpPackageName').invoke<String>();

  /// Return the full application info for this context's package. */
  ApplicationInfo get applicationInfo =>
      ApplicationInfo.from(_target.method('getApplicationInfo'));

  /// Return the full path to this context's primary Android package.
  /// The Android package is a ZIP file which contains the application's
  /// primary resources.
  ///
  /// <p>Note: this is not generally useful for applications, since they should
  /// not be directly accessing the file system.
  ///
  /// @return String Path to the resources.
  ///
  Future<String> get packageResourcePath =>
      _target.method('getPackageResourcePath').invoke<String>();

  /// Return the full path to this context's primary Android package.
  /// The Android package is a ZIP file which contains application's
  /// primary code and assets.
  ///
  /// <p>Note: this is not generally useful for applications, since they should
  /// not be directly accessing the file system.
  ///
  /// @return String Path to the code and assets.
  ///
  Future<String> get packageCodePath =>
      _target.method('getPackageCodePath').invoke<String>();

  /// @hide
  /// @deprecated use {@link #getSharedPreferencesPath(String)}
  ///
  NativeTarget sharedPrefsFile(String name) =>
      _target.method('getSharedPrefsFile', arguments: [name]);

  /// Retrieve and hold the contents of the preferences file 'name', returning
  /// a SharedPreferences through which you can retrieve and modify its
  /// values.  Only one instance of the SharedPreferences object is returned
  /// to any callers for the same name, meaning they will see each other's
  /// edits as soon as they are made.
  ///
  /// This method is thead-safe.
  ///
  /// @param name Desired preferences file. If a preferences file by this name
  /// does not exist, it will be created when you retrieve an
  /// editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).
  /// @param mode Operating mode.
  ///
  /// @return The single {@link SharedPreferences} instance that can be used
  ///         to retrieve and modify the preference values.
  ///
  /// @see #MODE_PRIVATE
  ///
  SharedPreferences sharedPreferences(String name, int mode) =>
      SharedPreferences(
          _target.method('getSharedPreferences', arguments: [name, mode]));

  /// Delete an existing shared preferences file.
  ///
  /// @param name The name (unique in the application package) of the shared
  ///            preferences file.
  /// @return {@code true} if the shared preferences file was successfully
  ///         deleted; else {@code false}.
  /// @see #getSharedPreferences(String, int)
  ///
  Future<bool> deleteSharedPreferences(String name) => _target
      .method('deleteSharedPreferences', arguments: [name]).invoke<bool>();

  /// @hide */
  Future<void> reloadSharedPreferences() =>
      _target.method('reloadSharedPreferences').invoke<void>();

  /// Delete the given private file associated with this Context's
  /// application package.
  ///
  /// @param name The name of the file to delete; can not contain path
  ///             separators.
  ///
  /// @return {@code true} if the file was successfully deleted; else
  ///         {@code false}.
  ///
  /// @see #openFileInput
  /// @see #openFileOutput
  /// @see #fileList
  /// @see java.io.File#delete()
  ///
  Future<bool> deleteFile(String name) =>
      _target.method('deleteFile', arguments: [name]).invoke<bool>();

  /// Returns the absolute path to the directory on the filesystem where all
  /// private files belonging to this app are stored. Apps should not use this
  /// path directly; they should instead use {@link #getFilesDir()},
  /// {@link #getCacheDir()}, {@link #getDir(String, int)}, or other storage
  /// APIs on this class.
  ///
  /// @see ApplicationInfo#dataDir
  ///
  NativeTarget get dataDir => _target.method('getDataDir');

  /// Returns the absolute path to the directory on the filesystem where files
  /// created with {@link #openFileOutput} are stored.
  ///
  /// @return The path of the directory holding application files.
  /// @see #openFileOutput
  /// @see #getFileStreamPath
  /// @see #getDir
  ///
  NativeTarget get filesDir => _target.method('getFilesDir');

  /// Returns the absolute path to the directory on the filesystem similar to
  /// {@link #getFilesDir()}. The difference is that files placed under this
  /// directory will be excluded from automatic backup to remote storage. See
  /// {@link android.app.backup.BackupAgent BackupAgent} for a full discussion
  /// of the automatic backup mechanism in Android.
  ///
  /// @return The path of the directory holding application files that will not
  ///         be automatically backed up to remote storage.
  /// @see #openFileOutput
  /// @see #getFileStreamPath
  /// @see #getDir
  /// @see android.app.backup.BackupAgent
  ///
  NativeTarget get noBackupFilesDir => _target.method('getNoBackupFilesDir');

  /// Returns the absolute path to the directory on the primary shared/external
  /// storage device where the application can place persistent files it owns.
  /// These files are internal to the applications, and not typically visible
  /// to the user as media.
  ///
  /// @param type The type of files directory to return. May be {@code null}
  ///            for the root of the files directory or one of the following
  ///            constants for a subdirectory:
  ///            {@link android.os.Environment#DIRECTORY_MUSIC},
  ///            {@link android.os.Environment#DIRECTORY_PODCASTS},
  ///            {@link android.os.Environment#DIRECTORY_RINGTONES},
  ///            {@link android.os.Environment#DIRECTORY_ALARMS},
  ///            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
  ///            {@link android.os.Environment#DIRECTORY_PICTURES}, or
  ///            {@link android.os.Environment#DIRECTORY_MOVIES}.
  /// @return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  /// @see #getFilesDir
  /// @see #getExternalFilesDirs(String)
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget externalFilesDir(String type) =>
      _target.method('getExternalFilesDir', arguments: [type]);

  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place
  /// persistent files it owns. These files are internal to the application,
  /// and not typically visible to the user as media.
  ///
  /// @param type The type of files directory to return. May be {@code null}
  ///            for the root of the files directory or one of the following
  ///            constants for a subdirectory:
  ///            {@link android.os.Environment#DIRECTORY_MUSIC},
  ///            {@link android.os.Environment#DIRECTORY_PODCASTS},
  ///            {@link android.os.Environment#DIRECTORY_RINGTONES},
  ///            {@link android.os.Environment#DIRECTORY_ALARMS},
  ///            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
  ///            {@link android.os.Environment#DIRECTORY_PICTURES}, or
  ///            {@link android.os.Environment#DIRECTORY_MOVIES}.
  /// @return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         {@link #getExternalFilesDir(String)}.
  /// @see #getExternalFilesDir(String)
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget externalFilesDirs(String type) =>
      _target.method('getExternalFilesDirs', arguments: [type]);

  /// Return the primary shared/external storage directory where this
  /// application's OBB files (if there are any) can be found. Note if the
  /// application does not have any OBB files, this directory may not exist.
  ///
  /// @return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  /// @see #getObbDirs()
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget get obbDir => _target.method('getObbDir');

  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application's OBB files (if
  /// there are any) can be found. Note if the application does not have any
  /// OBB files, these directories may not exist.
  ///
  /// @return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         {@link #getObbDir()}
  /// @see #getObbDir()
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget get obbDirs => _target.method('getObbDirs');

  /// Returns the absolute path to the application specific cache directory on
  /// the filesystem.
  ///
  /// @return The path of the directory holding application cache files.
  /// @see #openFileOutput
  /// @see #getFileStreamPath
  /// @see #getDir
  /// @see #getExternalCacheDir
  ///
  NativeTarget get cacheDir => _target.method('getCacheDir');

  /// Returns the absolute path to the application specific cache directory on
  /// the filesystem designed for storing cached code.
  ///
  /// @return The path of the directory holding application code cache files.
  ///
  NativeTarget get codeCacheDir => _target.method('getCodeCacheDir');

  /// Returns absolute path to application-specific directory on the primary
  /// shared/external storage device where the application can place cache
  /// files it owns. These files are internal to the application, and not
  /// typically visible to the user as media.
  ///
  /// @return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  /// @see #getCacheDir
  /// @see #getExternalCacheDirs()
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget get externalCacheDir => _target.method('getExternalCacheDir');

  /// Returns absolute path to application-specific directory in the preloaded cache.
  /// <p>Files stored in the cache directory can be deleted when the device runs low on storage.
  /// There is no guarantee when these files will be deleted.
  /// @hide
  ///
  NativeTarget get preloadsFileCache => _target.method('getPreloadsFileCache');

  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place cache
  /// files it owns. These files are internal to the application, and not
  /// typically visible to the user as media.
  ///
  /// @return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         {@link #getExternalCacheDir()}.
  /// @see #getExternalCacheDir()
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget get externalCacheDirs => _target.method('getExternalCacheDirs');

  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place media
  /// files. These files are scanned and made available to other apps through
  /// {@link MediaStore}.
  ///
  /// @return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available.
  /// @see Environment#getExternalStorageState(File)
  /// @see Environment#isExternalStorageEmulated(File)
  /// @see Environment#isExternalStorageRemovable(File)
  ///
  NativeTarget get externalMediaDirs => _target.method('getExternalMediaDirs');

  /// Returns an array of strings naming the private files associated with
  /// this Context's application package.
  ///
  /// @return Array of strings naming the private files.
  ///
  /// @see #openFileInput
  /// @see #openFileOutput
  /// @see #deleteFile
  ///
  Future<List<String>> get fileList =>
      _target.method('fileList').invoke<List<String>>();

  /// Delete an existing private SQLiteDatabase associated with this Context's
  /// application package.
  ///
  /// @param name The name (unique in the application package) of the
  ///             database.
  ///
  /// @return {@code true} if the database was successfully deleted; else {@code false}.
  ///
  /// @see #openOrCreateDatabase
  ///
  Future<bool> deleteDatabase(String name) =>
      _target.method('deleteDatabase', arguments: [name]).invoke<bool>();

  /// Returns the absolute path on the filesystem where a database created with
  /// {@link #openOrCreateDatabase} is stored.
  /// <p>
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// @param name The name of the database for which you would like to get
  ///          its path.
  ///
  /// @return An absolute path to the given database.
  ///
  /// @see #openOrCreateDatabase
  ///
  NativeTarget databasePath(String name) =>
      _target.method('getDatabasePath', arguments: [name]);

  /// Returns an array of strings naming the private databases associated with
  /// this Context's application package.
  ///
  /// @return Array of strings naming the private databases.
  ///
  /// @see #openOrCreateDatabase
  /// @see #deleteDatabase
  ///
  Future<List<String>> get databaseList =>
      _target.method('databaseList').invoke<List<String>>();

  /// @deprecated Use {@link android.app.WallpaperManager#getDrawable
  /// WallpaperManager.get()} instead.
  ///
  NativeTarget get wallpaper => _target.method('getWallpaper');

  /// @deprecated Use {@link android.app.WallpaperManager#peekDrawable
  /// WallpaperManager.peek()} instead.
  ///
  NativeTarget get peekWallpaper => _target.method('peekWallpaper');

  /// @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumWidth()
  /// WallpaperManager.getDesiredMinimumWidth()} instead.
  ///
  Future<int> get wallpaperDesiredMinimumWidth =>
      _target.method('getWallpaperDesiredMinimumWidth').invoke<int>();

  /// @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumHeight()
  /// WallpaperManager.getDesiredMinimumHeight()} instead.
  ///
  Future<int> get wallpaperDesiredMinimumHeight =>
      _target.method('getWallpaperDesiredMinimumHeight').invoke<int>();

  /// @deprecated Use {@link android.app.WallpaperManager#clear
  /// WallpaperManager.clear()} instead.
  /// <p>This method requires the caller to hold the permission
  /// {@link android.Manifest.permission#SET_WALLPAPER}.
  ///
  Future<void> clearWallpaper() =>
      _target.method('clearWallpaper').invoke<void>();

  /// Identifies whether this Context instance will be able to process calls to
  /// {@link #startActivityForResult(String, Intent, int, Bundle)}.
  /// @hide
  ///
  Future<bool> get canStartActivityForResult =>
      _target.method('canStartActivityForResult').invoke<bool>();

  /// Return the handle to a system-level service by name. The class of the
  /// returned object varies by the requested name. Currently available names
  ///
  /// @param name The name of the desired service.
  ///
  /// @return The service or null if the name does not exist.
  ///
  ///
  NativeTarget systemService(String name) =>
      _target.method('getSystemService', arguments: [name]);

  /// Determine whether the given permission is allowed for a particular
  /// process and user ID running in the system.
  ///
  /// @param permission The name of the permission being checked.
  /// @param pid The process ID being checked against.  Must be > 0.
  /// @param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if the given
  /// pid/uid is allowed that permission, or
  /// {@link PackageManager#PERMISSION_DENIED} if it is not.
  ///
  /// @see PackageManager#checkPermission(String, String)
  /// @see #checkCallingPermission
  ///
  Future<int> checkPermission(String permission, int pid, int uid) =>
      _target.method('checkPermission',
          arguments: [permission, pid, uid]).invoke<int>();

  /// Determine whether the calling process of an IPC you are handling has been
  /// granted a particular permission.  This is basically the same as calling
  /// {@link #checkPermission(String, int, int)} with the pid and uid returned
  /// by {@link android.os.Binder#getCallingPid} and
  /// {@link android.os.Binder#getCallingUid}.  One important difference
  /// is that if you are not currently processing an IPC, this function
  /// will always fail.  This is done to protect against accidentally
  /// leaking permissions; you can use {@link #checkCallingOrSelfPermission}
  /// to avoid this protection.
  ///
  /// @param permission The name of the permission being checked.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if the calling
  /// pid/uid is allowed that permission, or
  /// {@link PackageManager#PERMISSION_DENIED} if it is not.
  ///
  /// @see PackageManager#checkPermission(String, String)
  /// @see #checkPermission
  /// @see #checkCallingOrSelfPermission
  ///
  Future<int> checkCallingPermission(String permission) => _target
      .method('checkCallingPermission', arguments: [permission]).invoke<int>();

  /// Determine whether the calling process of an IPC <em>or you</em> have been
  /// granted a particular permission.  This is the same as
  /// {@link #checkCallingPermission}, except it grants your own permissions
  /// if you are not currently processing an IPC.  Use with care!
  ///
  /// @param permission The name of the permission being checked.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if the calling
  /// pid/uid is allowed that permission, or
  /// {@link PackageManager#PERMISSION_DENIED} if it is not.
  ///
  /// @see PackageManager#checkPermission(String, String)
  /// @see #checkPermission
  /// @see #checkCallingPermission
  ///
  Future<int> checkCallingOrSelfPermission(String permission) =>
      _target.method('checkCallingOrSelfPermission',
          arguments: [permission]).invoke<int>();

  /// Determine whether <em>you</em> have been granted a particular permission.
  ///
  /// @param permission The name of the permission being checked.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if you have the
  /// permission, or {@link PackageManager#PERMISSION_DENIED} if not.
  ///
  /// @see PackageManager#checkPermission(String, String)
  /// @see #checkCallingPermission(String)
  ///
  Future<int> checkSelfPermission(String permission) => _target
      .method('checkSelfPermission', arguments: [permission]).invoke<int>();

  /// If the given permission is not allowed for a particular process
  /// and user ID running in the system, throw a {@link SecurityException}.
  ///
  /// @param permission The name of the permission being checked.
  /// @param pid The process ID being checked against.  Must be &gt; 0.
  /// @param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  /// @param message A message to include in the exception if it is thrown.
  ///
  /// @see #checkPermission(String, int, int)
  ///
  Future<void> enforcePermission(
          String permission, int pid, int uid, String message) =>
      _target.method('enforcePermission',
          arguments: [permission, pid, uid, message]).invoke<void>();

  /// If the calling process of an IPC you are handling has not been
  /// granted a particular permission, throw a {@link
  /// SecurityException}.  This is basically the same as calling
  /// {@link #enforcePermission(String, int, int, String)} with the
  /// pid and uid returned by {@link android.os.Binder#getCallingPid}
  /// and {@link android.os.Binder#getCallingUid}.  One important
  /// difference is that if you are not currently processing an IPC,
  /// this function will always throw the SecurityException.  This is
  /// done to protect against accidentally leaking permissions; you
  /// can use {@link #enforceCallingOrSelfPermission} to avoid this
  /// protection.
  ///
  /// @param permission The name of the permission being checked.
  /// @param message A message to include in the exception if it is thrown.
  ///
  /// @see #checkCallingPermission(String)
  ///
  Future<void> enforceCallingPermission(String permission, String message) =>
      _target.method('enforceCallingPermission',
          arguments: [permission, message]).invoke<void>();

  /// If neither you nor the calling process of an IPC you are
  /// handling has been granted a particular permission, throw a
  /// {@link SecurityException}.  This is the same as {@link
  /// #enforceCallingPermission}, except it grants your own
  /// permissions if you are not currently processing an IPC.  Use
  /// with care!
  ///
  /// @param permission The name of the permission being checked.
  /// @param message A message to include in the exception if it is thrown.
  ///
  /// @see #checkCallingOrSelfPermission(String)
  ///
  Future<void> enforceCallingOrSelfPermission(
          String permission, String message) =>
      _target.method('enforceCallingOrSelfPermission',
          arguments: [permission, message]).invoke<void>();

  /// Grant permission to access a specific Uri to another package, regardless
  /// of whether that package has general permission to access the Uri's
  /// content provider.  This can be used to grant specific, temporary
  /// permissions, typically in response to user interaction (such as the
  /// user opening an attachment that you would like someone else to
  /// display).
  ///
  /// @param toPackage The package you would like to allow to access the Uri.
  /// @param uri The Uri you would like to grant access to.
  /// @param modeFlags The desired access modes.
  ///
  /// @see #revokeUriPermission
  ///
  Future<void> grantUriPermission(String toPackage, Uri uri, int modeFlags) =>
      _target.method('grantUriPermission',
          arguments: [toPackage, uri, modeFlags]).invoke<void>();

  /// Remove all permissions to access a particular content provider Uri
  /// that were previously added with {@link #grantUriPermission} or <em>any other</em> mechanism.
  /// The given Uri will match all previously granted Uris that are the same or a
  /// sub-path of the given Uri.  That is, revoking "content://foo/target" will
  /// revoke both "content://foo/target" and "content://foo/target/sub", but not
  /// "content://foo".  It will not remove any prefix grants that exist at a
  /// higher level.
  ///
  /// @param uri The Uri you would like to revoke access to.
  /// @param modeFlags The access modes to revoke.
  ///
  /// @see #grantUriPermission
  ///
  Future<void> revokeUriPermission(String toPackage, int modeFlags,
          {Uri uri}) =>
      _target.method('revokeUriPermission',
          arguments: [toPackage, uri, modeFlags]).invoke<void>();

  /// Determine whether the calling process and user ID has been
  /// granted permission to access a specific URI.  This is basically
  /// the same as calling {@link #checkUriPermission(Uri, int, int,
  /// int)} with the pid and uid returned by {@link
  /// android.os.Binder#getCallingPid} and {@link
  /// android.os.Binder#getCallingUid}.  One important difference is
  /// that if you are not currently processing an IPC, this function
  /// will always fail.
  ///
  /// @param uri The uri that is being checked.
  /// @param modeFlags The access modes to check.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if the caller
  /// is allowed to access that uri, or
  /// {@link PackageManager#PERMISSION_DENIED} if it is not.
  ///
  /// @see #checkUriPermission(Uri, int, int, int)
  ///
  Future<int> checkCallingUriPermission(Uri uri, int modeFlags) =>
      _target.method('checkCallingUriPermission',
          arguments: [uri, modeFlags]).invoke<int>();

  /// Determine whether the calling process of an IPC <em>or you</em> has been granted
  /// permission to access a specific URI.  This is the same as
  /// {@link #checkCallingUriPermission}, except it grants your own permissions
  /// if you are not currently processing an IPC.  Use with care!
  ///
  /// @param uri The uri that is being checked.
  /// @param modeFlags The access modes to check.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if the caller
  /// is allowed to access that uri, or
  /// {@link PackageManager#PERMISSION_DENIED} if it is not.
  ///
  /// @see #checkCallingUriPermission
  ///
  Future<int> checkCallingOrSelfUriPermission(Uri uri, int modeFlags) =>
      _target.method('checkCallingOrSelfUriPermission',
          arguments: [uri, modeFlags]).invoke<int>();

  /// Check both a Uri and normal permission.  This allows you to perform
  /// both {@link #checkPermission} and {@link #checkUriPermission} in one
  /// call.
  ///
  /// @param uri The Uri whose permission is to be checked, or null to not
  /// do this check.
  /// @param readPermission The permission that provides overall read access,
  /// or null to not do this check.
  /// @param writePermission The permission that provides overall write
  /// access, or null to not do this check.
  /// @param pid The process ID being checked against.  Must be &gt; 0.
  /// @param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  /// @param modeFlags The access modes to check.
  ///
  /// @return {@link PackageManager#PERMISSION_GRANTED} if the caller
  /// is allowed to access that uri or holds one of the given permissions, or
  /// {@link PackageManager#PERMISSION_DENIED} if it is not.
  ///
  Future<int> checkUriPermission(Uri uri, int pid, int uid, int modeFlags,
          {String readPermission, String writePermission}) =>
      _target.method('checkUriPermission', arguments: [
        uri,
        readPermission,
        writePermission,
        pid,
        uid,
        modeFlags
      ]).invoke<int>();

  /// If the calling process and user ID has not been granted
  /// permission to access a specific URI, throw {@link
  /// SecurityException}.  This is basically the same as calling
  /// {@link #enforceUriPermission(Uri, int, int, int, String)} with
  /// the pid and uid returned by {@link
  /// android.os.Binder#getCallingPid} and {@link
  /// android.os.Binder#getCallingUid}.  One important difference is
  /// that if you are not currently processing an IPC, this function
  /// will always throw a SecurityException.
  ///
  /// @param uri The uri that is being checked.
  /// @param modeFlags The access modes to enforce.
  /// @param message A message to include in the exception if it is thrown.
  ///
  /// @see #checkCallingUriPermission(Uri, int)
  ///
  Future<void> enforceCallingUriPermission(
          Uri uri, int modeFlags, String message) =>
      _target.method('enforceCallingUriPermission',
          arguments: [uri, modeFlags, message]).invoke<void>();

  /// If the calling process of an IPC <em>or you</em> has not been
  /// granted permission to access a specific URI, throw {@link
  /// SecurityException}.  This is the same as {@link
  /// #enforceCallingUriPermission}, except it grants your own
  /// permissions if you are not currently processing an IPC.  Use
  /// with care!
  ///
  /// @param uri The uri that is being checked.
  /// @param modeFlags The access modes to enforce.
  /// @param message A message to include in the exception if it is thrown.
  ///
  /// @see #checkCallingOrSelfUriPermission(Uri, int)
  ///
  Future<void> enforceCallingOrSelfUriPermission(
          Uri uri, int modeFlags, String message) =>
      _target.method('enforceCallingOrSelfUriPermission',
          arguments: [uri, modeFlags, message]).invoke<void>();

  /// Enforce both a Uri and normal permission.  This allows you to perform
  /// both {@link #enforcePermission} and {@link #enforceUriPermission} in one
  /// call.
  ///
  /// @param uri The Uri whose permission is to be checked, or null to not
  /// do this check.
  /// @param readPermission The permission that provides overall read access,
  /// or null to not do this check.
  /// @param writePermission The permission that provides overall write
  /// access, or null to not do this check.
  /// @param pid The process ID being checked against.  Must be &gt; 0.
  /// @param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  /// @param modeFlags The access modes to enforce.
  /// @param message A message to include in the exception if it is thrown.
  ///
  /// @see #checkUriPermission(Uri, String, String, int, int, int)
  ///
  Future<void> enforceUriPermission(
          Uri uri, int pid, int uid, int modeFlags, String message,
          {String readPermission, String writePermission}) =>
      _target.method('enforceUriPermission', arguments: [
        uri,
        readPermission,
        writePermission,
        pid,
        uid,
        modeFlags,
        message
      ]).invoke<void>();

  /// Get the user associated with this context
  /// @hide
  ///
  Future<int> get userId => _target.method('getUserId').invoke<int>();

  /// Gets the display adjustments holder for this context.  This information
  /// is provided on a per-application or activity basis and is used to simulate lower density
  /// display metrics for legacy applications and restricted screen sizes.
  ///
  /// @param displayId The display id for which to get compatibility info.
  /// @return The compatibility info holder, or null if not required by the application.
  /// @hide
  ///
  NativeTarget displayAdjustments(int displayId) =>
      _target.method('getDisplayAdjustments', arguments: [displayId]);

  /// @hide
  ///
  NativeTarget get display => _target.method('getDisplay');

  /// @hide
  ///
  Future<void> updateDisplay(int displayId) =>
      _target.method('updateDisplay', arguments: [displayId]).invoke<void>();

  /// Indicates whether this Context is restricted.
  ///
  /// @return {@code true} if this Context is restricted, {@code false} otherwise.
  ///
  /// @see #CONTEXT_RESTRICTED
  ///
  Future<bool> get restricted => _target.method('isRestricted').invoke<bool>();

  /// Indicates if the storage APIs of this Context are backed by
  /// device-protected storage.
  ///
  /// @see #createDeviceProtectedStorageContext()
  ///
  Future<bool> get deviceProtectedStorage =>
      _target.method('isDeviceProtectedStorage').invoke<bool>();

  /// Indicates if the storage APIs of this Context are backed by
  /// credential-protected storage.
  ///
  /// @see #createCredentialProtectedStorageContext()
  /// @hide
  ///
  Future<bool> get credentialProtectedStorage =>
      _target.method('isCredentialProtectedStorage').invoke<bool>();

  /// Returns true if the context can load unsafe resources, e.g. fonts.
  /// @hide
  ///
  Future<bool> get canLoadUnsafeResources =>
      _target.method('canLoadUnsafeResources').invoke<bool>();

  /// @hide
  ///
  NativeTarget get activityToken => _target.method('getActivityToken');

  /// @hide
  ///
  Future<bool> get autofillCompatibilityEnabled =>
      _target.method('isAutofillCompatibilityEnabled').invoke<bool>();

  /// @hide
  ///
  Future<void> setAutofillCompatibilityEnabled({bool autofillCompatEnabled}) =>
      _target.method('setAutofillCompatibilityEnabled',
          arguments: [autofillCompatEnabled]).invoke<void>();

  /// Throws an exception if the Context is using system resources,
  /// which are non-runtime-overlay-themable and may show inconsistent UI.
  /// @hide
  ///
  Future<void> assertRuntimeOverlayThemable() =>
      _target.method('assertRuntimeOverlayThemable').invoke<void>();
}
